import { FileType, GeneratedFile, FILE_NAMES } from './types';
import { getTechnologyById } from './technologies';

interface MergeResult {
  content: string;
  sections: string[];
}

const HEADER_TEMPLATES: Record<FileType, string> = {
  gitignore: `# ═══════════════════════════════════════════════════════════════════════════════
# .gitignore - Generated by GitConfig Pro
# https://git-config-pro.carlosleoncode.dev
# ═══════════════════════════════════════════════════════════════════════════════

`,
  gitattributes: `# ═══════════════════════════════════════════════════════════════════════════════
# .gitattributes - Generated by GitConfig Pro
# https://git-config-pro.carlosleoncode.dev
# ═══════════════════════════════════════════════════════════════════════════════

# Auto detect text files and perform LF normalization
* text=auto

`,
  editorconfig: `# ═══════════════════════════════════════════════════════════════════════════════
# .editorconfig - Generated by GitConfig Pro
# https://git-config-pro.carlosleoncode.dev
# ═══════════════════════════════════════════════════════════════════════════════

# EditorConfig helps maintain consistent coding styles
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

`,
  dockerignore: `# ═══════════════════════════════════════════════════════════════════════════════
# .dockerignore - Generated by GitConfig Pro
# https://git-config-pro.carlosleoncode.dev
# ═══════════════════════════════════════════════════════════════════════════════

`,
  prettierignore: `# ═══════════════════════════════════════════════════════════════════════════════
# .prettierignore - Generated by GitConfig Pro
# https://git-config-pro.carlosleoncode.dev
# ═══════════════════════════════════════════════════════════════════════════════

`,
  eslintignore: `# ═══════════════════════════════════════════════════════════════════════════════
# .eslintignore - Generated by GitConfig Pro
# https://git-config-pro.carlosleoncode.dev
# ═══════════════════════════════════════════════════════════════════════════════

`,
  license: '',
};

const SECTION_DIVIDER = '\n# ───────────────────────────────────────────────────────────────────────────────\n';

export function mergeTemplates(selectedIds: string[], fileType: FileType): MergeResult {
  const allLines: Set<string> = new Set();
  const sections: string[] = [];
  let content = HEADER_TEMPLATES[fileType];

  const selectedTechnologies = selectedIds
    .map(getTechnologyById)
    .filter((t) => t !== undefined);

  for (const tech of selectedTechnologies) {
    const fileContent = tech.files[fileType];

    if (fileContent && fileContent.length > 0) {
      sections.push(tech.name);

      // Add section header
      content += `# ${tech.icon} ${tech.name}\n`;

      // Process lines and avoid duplicates
      for (const line of fileContent) {
        // Skip empty lines at the start of a section
        if (line === '' && content.endsWith(`# ${tech.icon} ${tech.name}\n`)) {
          continue;
        }

        // Check for duplicates (ignoring comments and empty lines)
        const trimmedLine = line.trim();
        if (trimmedLine && !trimmedLine.startsWith('#')) {
          if (allLines.has(trimmedLine)) {
            continue;
          }
          allLines.add(trimmedLine);
        }

        content += line + '\n';
      }

      content += SECTION_DIVIDER;
    }
  }

  // Clean up trailing divider
  if (content.endsWith(SECTION_DIVIDER)) {
    content = content.slice(0, -SECTION_DIVIDER.length) + '\n';
  }

  return { content: content.trim() + '\n', sections };
}

export function generateAllFiles(selectedIds: string[]): GeneratedFile[] {
  const fileTypes: FileType[] = ['gitignore', 'gitattributes', 'editorconfig', 'dockerignore', 'prettierignore', 'eslintignore'];
  const files: GeneratedFile[] = [];

  for (const fileType of fileTypes) {
    const { content } = mergeTemplates(selectedIds, fileType);

    // Only add file if it has content beyond the header
    const headerLength = HEADER_TEMPLATES[fileType].length;
    if (content.length > headerLength + 50) {
      files.push({
        type: fileType,
        filename: FILE_NAMES[fileType],
        content,
      });
    }
  }

  return files;
}

export function detectTechnologiesFromPackageJson(packageJson: string): string[] {
  try {
    const pkg = JSON.parse(packageJson);
    const detected: Set<string> = new Set();

    const allDeps = {
      ...pkg.dependencies,
      ...pkg.devDependencies,
    };

    // Detection rules
    const rules: Record<string, string[]> = {
      nextjs: ['next'],
      react: ['react', 'react-dom'],
      vue: ['vue', 'nuxt'],
      angular: ['@angular/core'],
      typescript: ['typescript'],
      tailwind: ['tailwindcss'],
    };

    for (const [techId, packages] of Object.entries(rules)) {
      if (packages.some((pkg) => allDeps[pkg])) {
        detected.add(techId);
      }
    }

    // Always add Node.js for package.json
    detected.add('node');
    detected.add('env');

    return Array.from(detected);
  } catch {
    return [];
  }
}

export function detectTechnologiesFromRequirementsTxt(requirements: string): string[] {
  const detected: Set<string> = new Set(['python', 'env']);
  const lines = requirements.toLowerCase().split('\n');

  const rules: Record<string, string[]> = {
    django: ['django'],
    flask: ['flask'],
  };

  for (const [techId, packages] of Object.entries(rules)) {
    if (packages.some((pkg) => lines.some((line) => line.includes(pkg)))) {
      detected.add(techId);
    }
  }

  return Array.from(detected);
}

export function generateCurlCommand(selectedIds: string[]): string {
  const encodedIds = encodeURIComponent(selectedIds.join(','));
  return `curl -sL "https://gitconfig.pro/api/generate?tech=${encodedIds}" | tar -xz`;
}
